1. GenerateCompositeSpec
HTTP

Method: POST

Route: /api/GenerateCompositeSpec

Request body
{
  "documentation": "<string – vendor docs in markdown/HTML>"
}


documentation (required): the full text of the datasheet section for this device (or at least the TLV / payload section).

If body is empty or invalid JSON:

{ "error": "Request body is empty." }


or

{ "error": "Invalid JSON body." }


If documentation is missing/blank:

{ "error": "Property 'documentation' is required." }

Success response
{
  "compositeSpec": "COMPOSITE_TLVS\n- channel=...\n...\nBITFIELDS\n..."
}


compositeSpec: text block containing COMPOSITE_TLVS and BITFIELDS.

If OpenAI throws internally, you get:

{ "error": "<exception message>" }


with HTTP 500.

2. GenerateRulesBlock
HTTP

Method: POST

Route: /api/GenerateRulesBlock

Request body
{
  "documentation": "<string – vendor docs>",
  "sensorSpecificPrompt": "<optional string – human hints>",
  "compositeSpec": "<optional string – output of GenerateCompositeSpec>"
}


documentation (required)

sensorSpecificPrompt (optional; can be empty)

compositeSpec (optional; can be empty, but recommended from step 1)

If body is empty/invalid JSON:

{ "error": "Request body is empty." }


or

{ "error": "Invalid JSON body." }


If documentation is missing/blank:

{ "error": "Property 'documentation' is required." }

Success response
{
  "rulesBlock": "# DECODING RULES (...)\n# ...\nMAP: channel=...\n..."
}


rulesBlock: the entire DECODING RULES block as plain text (no code fences).

500 errors same pattern as above.

3. ExtractExamplesTables
HTTP

Method: POST

Route: /api/ExtractExamplesTables

Request body
{
  "documentation": "<string – vendor docs>"
}


documentation (required)

On errors with request:

Empty body: { "error": "Request body is empty." }

Invalid JSON: { "error": "Invalid JSON body." }

Missing/blank documentation: { "error": "Property 'documentation' is required." }

Success response
{
  "examplesTablesMd": "| Channel | Type | Value | ...\n| --- | --- | --- | ...\n..."
}


examplesTablesMd: markdown containing the example tables (basic + sensor examples), in the strict format your prompt describes.

4. ReconcileRulesBlock
HTTP

Method: POST

Route: /api/ReconcileRulesBlock

Request body
{
  "rulesBlock": "<string – current DECODING RULES>",
  "examplesTablesMd": "<string – from ExtractExamplesTables>",
  "compositeSpec": "<optional string – from GenerateCompositeSpec>"
}


Required:

rulesBlock

examplesTablesMd

compositeSpec may be empty, but is recommended.

Error cases:

Empty body: { "error": "Request body is empty." }

Invalid JSON: { "error": "Invalid JSON body." }

Missing/blank rulesBlock or examplesTablesMd:

{ "error": "Properties 'rulesBlock' and 'examplesTablesMd' are required." }

Success response
{
  "rulesBlock": "<string – corrected / reconciled DECODING RULES>"
}


So this function outputs a new rulesBlock with the same format, just adjusted.

5. GenerateDecoder
HTTP

Method: POST

Route: /api/GenerateDecoder

Request body
{
  "rulesBlock": "<string – reconciled DECODING RULES>",
  "examplesTablesMd": "<string – markdown examples>"
}


Both are required.

Errors:

Empty body: { "error": "Request body is empty." }

Invalid JSON: { "error": "Invalid JSON body." }

Missing/blank rulesBlock or examplesTablesMd:

{ "error": "Properties 'rulesBlock' and 'examplesTablesMd' are required." }

Success response
{
  "decoderCode": "using System;\nusing Microsoft.AspNetCore.Mvc;\n..."
}


decoderCode: a single C# source file for the Azure Function decoder, as plain text (no backticks).

6. AutoRepairDecoder
HTTP

Method: POST

Route: /api/AutoRepairDecoder

Request body
{
  "rulesBlock": "<string – DECODING RULES>",
  "examplesTablesMd": "<string – markdown examples>",
  "decoderCode": "<string – existing/initial C# decoder code>"
}


All three properties are required.

Errors:

Empty body: { "error": "Request body is empty." }

Invalid JSON: { "error": "Invalid JSON body." }

Missing/blank fields:

{ "error": "Properties 'rulesBlock', 'examplesTablesMd' and 'decoderCode' are required." }

Success response
{
  "repairedCode": "using System;\nusing Microsoft.AspNetCore.Mvc;\n..."
}


repairedCode: the fixed/improved version of your decoder.

7. DecoderFeedback
HTTP

Method: POST

Route: /api/DecoderFeedback

Request body
{
  "rulesBlock": "<string – DECODING RULES>",
  "examplesTablesMd": "<string – markdown examples>",
  "decoderCode": "<string – candidate decoder C#>"
}


All required.

Errors:

Empty body: { "error": "Request body is empty." }

Invalid JSON: { "error": "Invalid JSON body." }

Missing/blank properties:

{ "error": "Properties 'rulesBlock', 'examplesTablesMd' and 'decoderCode' are required." }

Success response
{
  "feedbackMarkdown": "Overall correctness: 82%\n\n## Issues\n- ...\n\n## Proposed fixes\nnow you have:\n```csharp\n...\n```"
}


feedbackMarkdown: markdown with score, issues, and small now you have / replace with code patches.

Recommended end-to-end workflow

Here’s the sane pipeline that mirrors your console app – just split across HTTP calls.

Step 0: You provide the documentation

You (or your frontend) upload / paste the vendor PDF text (HTML/markdown) and keep it around client-side or in your backend so you can reuse it for multiple calls.

Let’s call it documentation.

Step 1: Discover composite TLVs and bitfields

Call: POST /api/GenerateCompositeSpec

Body:

{
  "documentation": "<your vendor docs>"
}


Response → compositeSpec.

You can optionally show compositeSpec to a human for manual tweaks, then pass the edited version into later steps.

Step 2: Generate initial DECODING RULES

Call: POST /api/GenerateRulesBlock

Body:

{
  "documentation": "<same docs>",
  "sensorSpecificPrompt": "<optional guidance from user>",
  "compositeSpec": "<compositeSpec from step 1>"
}


Response → rulesBlock (first pass).

You may let a human edit this rulesBlock if you want.

Step 3: Extract example tables

Call: POST /api/ExtractExamplesTables

Body:

{
  "documentation": "<same docs>"
}


Response → examplesTablesMd (markdown tables).

Again, user can review/edit if needed.

Step 4: Reconcile rules with examples & composite layout

Call: POST /api/ReconcileRulesBlock

Body:

{
  "rulesBlock": "<rulesBlock from step 2 or edited>",
  "examplesTablesMd": "<examplesTablesMd from step 3>",
  "compositeSpec": "<compositeSpec from step 1>"
}


Response → rulesBlock (updated/reconciled).

This is your authoritative DECODING RULES.

Step 5: Generate initial decoder code

Call: POST /api/GenerateDecoder

Body:

{
  "rulesBlock": "<final rulesBlock from step 4>",
  "examplesTablesMd": "<examplesTablesMd from step 3>"
}


Response → decoderCode (C# Azure Function).

This is your first working function.

Step 6 (optional loop): Auto-repair the decoder

If you (or tests) find issues:

Call: POST /api/AutoRepairDecoder

Body:

{
  "rulesBlock": "<final rulesBlock>",
  "examplesTablesMd": "<examplesTablesMd>",
  "decoderCode": "<current decoder code – maybe manually edited>"
}


Response → repairedCode.

You can feed the repaired code back into this step again if you want further iterations (or apply manual edits in between).

Step 7 (optional QA): Get feedback & patches

To get a review and concrete patch suggestions:

Call: POST /api/DecoderFeedback

Body:

{
  "rulesBlock": "<final rulesBlock>",
  "examplesTablesMd": "<examplesTablesMd>",
  "decoderCode": "<current decoder code (repaired or manual)>"
}


Response → feedbackMarkdown with score + issues + patch snippets.

You or your tooling can apply those patches manually or via your own code transformer, then (optionally) run AutoRepairDecoder again.

TL;DR flow diagram